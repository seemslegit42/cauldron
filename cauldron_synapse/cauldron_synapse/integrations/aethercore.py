"""
AetherCore integration module for Synapse
"""

import frappe
import json
from datetime import datetime, timedelta
import logging

# Configure logger
logger = logging.getLogger(__name__)

# Agent task handlers

def analyze_trend(task_data):
    """Handle synapse.analyze_trend agent task"""
    try:
        logger.info(f"Handling synapse.analyze_trend agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        start_date = task_data.get("start_date")
        end_date = task_data.get("end_date")
        analysis_type = task_data.get("analysis_type", "general")
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Get historical data
        historical_data = get_metric_historical_data(metric_id, start_date, end_date)
        
        # Perform trend analysis
        analysis_result = perform_trend_analysis(metric_doc, historical_data, analysis_type)
        
        # Store analysis result if requested
        if task_data.get("store_result", False):
            store_trend_analysis(metric_id, analysis_result, task_data)
        
        return {
            "success": True,
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "analysis_type": analysis_type,
            "analysis_result": analysis_result
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.analyze_trend task: {str(e)}")
        frappe.log_error(f"Error handling synapse.analyze_trend task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def generate_forecast(task_data):
    """Handle synapse.generate_forecast agent task"""
    try:
        logger.info(f"Handling synapse.generate_forecast agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        forecast_horizon = task_data.get("forecast_horizon", 30)
        forecast_frequency = task_data.get("forecast_frequency", "Daily")
        forecast_model = task_data.get("forecast_model", "ARIMA")
        model_parameters = task_data.get("model_parameters", {})
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Create a new forecast
        forecast_doc = frappe.new_doc("Forecast")
        forecast_doc.forecast_name = f"Agent Generated Forecast - {metric_doc.metric_name}"
        forecast_doc.metric = metric_id
        forecast_doc.description = f"Forecast generated by AetherCore agent task {task_data.get('task_id')}"
        forecast_doc.status = "Draft"
        forecast_doc.forecast_model = forecast_model
        forecast_doc.forecast_horizon = forecast_horizon
        forecast_doc.forecast_frequency = forecast_frequency
        forecast_doc.model_parameters = json.dumps(model_parameters) if isinstance(model_parameters, dict) else None
        forecast_doc.confidence_level = task_data.get("confidence_level", 95)
        forecast_doc.include_prediction_intervals = 1
        forecast_doc.created_by = "AetherCore Agent"
        forecast_doc.creation_date = datetime.now()
        forecast_doc.is_active = 1
        forecast_doc.insert()
        
        # Generate the forecast
        from cauldron_synapse.predictive_analytics.forecasting import generate_forecast as run_forecast
        forecast_result = run_forecast(forecast_doc.name)
        
        return {
            "success": forecast_result.get("success", False),
            "forecast_id": forecast_doc.name,
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "forecast_data": forecast_result.get("forecast"),
            "performance": forecast_result.get("performance")
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.generate_forecast task: {str(e)}")
        frappe.log_error(f"Error handling synapse.generate_forecast task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def detect_anomalies(task_data):
    """Handle synapse.detect_anomalies agent task"""
    try:
        logger.info(f"Handling synapse.detect_anomalies agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        lookback_days = task_data.get("lookback_days", 90)
        detection_methods = task_data.get("detection_methods", ["statistical", "ml", "time_series"])
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Run anomaly detection
        from cauldron_synapse.predictive_analytics.anomaly_detection import detect_anomalies_for_metric
        detection_result = detect_anomalies_for_metric(metric_id)
        
        return {
            "success": detection_result.get("success", False),
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "anomalies_found": detection_result.get("anomalies_found", 0),
            "anomalies": detection_result.get("anomalies", [])
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.detect_anomalies task: {str(e)}")
        frappe.log_error(f"Error handling synapse.detect_anomalies task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def recommend_actions(task_data):
    """Handle synapse.recommend_actions agent task"""
    try:
        logger.info(f"Handling synapse.recommend_actions agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        insight_type = task_data.get("insight_type", "trend")
        insight_data = task_data.get("insight_data", {})
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Generate recommendations based on insight type
        if insight_type == "trend":
            recommendations = generate_trend_recommendations(metric_doc, insight_data)
        elif insight_type == "anomaly":
            recommendations = generate_anomaly_recommendations(metric_doc, insight_data)
        elif insight_type == "forecast":
            recommendations = generate_forecast_recommendations(metric_doc, insight_data)
        else:
            recommendations = generate_general_recommendations(metric_doc, insight_data)
        
        # Create recommendation if requested
        recommendation_id = None
        if task_data.get("create_recommendation", False) and recommendations:
            recommendation_id = create_recommendation(metric_doc, insight_type, recommendations, task_data)
        
        return {
            "success": True,
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "insight_type": insight_type,
            "recommendations": recommendations,
            "recommendation_id": recommendation_id
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.recommend_actions task: {str(e)}")
        frappe.log_error(f"Error handling synapse.recommend_actions task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def explain_insight(task_data):
    """Handle synapse.explain_insight agent task"""
    try:
        logger.info(f"Handling synapse.explain_insight agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        insight_id = task_data.get("insight_id")
        format_type = task_data.get("format", "text")
        audience = task_data.get("audience", "technical")
        
        if not insight_id:
            return {
                "success": False,
                "error": "Missing required parameter: insight_id"
            }
        
        # Get insight details
        insight_doc = frappe.get_doc("AIInsight", insight_id)
        
        # Generate explanation based on format and audience
        explanation = generate_insight_explanation(insight_doc, format_type, audience)
        
        # Update insight with explanation if requested
        if task_data.get("update_insight", False):
            insight_doc.explanation = explanation
            insight_doc.save()
        
        return {
            "success": True,
            "insight_id": insight_id,
            "insight_title": insight_doc.title,
            "format": format_type,
            "audience": audience,
            "explanation": explanation
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.explain_insight task: {str(e)}")
        frappe.log_error(f"Error handling synapse.explain_insight task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

# Helper functions

def get_metric_historical_data(metric_id, start_date=None, end_date=None):
    """Get historical data for a metric"""
    try:
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Set default date range if not provided
        if not end_date:
            end_date = datetime.now().date()
        elif isinstance(end_date, str):
            end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
            
        if not start_date:
            start_date = end_date - timedelta(days=90)
        elif isinstance(start_date, str):
            start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
        
        # Get historical values
        # This would be implemented to fetch actual historical data
        # For now, return placeholder data
        
        # Generate some realistic sample data
        days = (end_date - start_date).days + 1
        dates = [start_date + timedelta(days=i) for i in range(days)]
        
        import numpy as np
        
        # Create a trend with seasonality and some noise
        trend = np.linspace(100, 150, days)  # Upward trend from 100 to 150
        seasonality = 20 * np.sin(np.linspace(0, 6*np.pi, days))  # Seasonal component
        noise = np.random.normal(0, 5, days)  # Random noise
        
        values = trend + seasonality + noise
        
        # Create data points
        data = [
            {"date": date.strftime("%Y-%m-%d"), "value": value}
            for date, value in zip(dates, values)
        ]
        
        return data
        
    except Exception as e:
        logger.error(f"Error getting historical data for metric {metric_id}: {str(e)}")
        frappe.log_error(f"Error getting historical data for metric {metric_id}: {str(e)}", "Historical Data Error")
        return []

def perform_trend_analysis(metric_doc, historical_data, analysis_type):
    """Perform trend analysis on historical data"""
    try:
        # This would be implemented with actual trend analysis logic
        # For now, return placeholder analysis
        
        import pandas as pd
        import numpy as np
        from scipy import stats
        
        # Convert to DataFrame
        df = pd.DataFrame(historical_data)
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        # Basic statistics
        mean_value = df['value'].mean()
        median_value = df['value'].median()
        std_dev = df['value'].std()
        min_value = df['value'].min()
        max_value = df['value'].max()
        
        # Trend analysis
        x = np.arange(len(df))
        y = df['value'].values
        slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
        
        trend_direction = "increasing" if slope > 0 else "decreasing"
        trend_strength = abs(r_value)
        trend_significance = p_value < 0.05
        
        # Seasonality detection (simplified)
        has_seasonality = False
        seasonality_period = None
        
        if len(df) >= 14:  # Need at least 2 weeks of data
            # Check for weekly seasonality
            weekly_corr = df['value'].autocorr(lag=7)
            if abs(weekly_corr) > 0.3:
                has_seasonality = True
                seasonality_period = 7
        
        # Volatility
        volatility = std_dev / mean_value
        
        # Outliers
        z_scores = np.abs(stats.zscore(df['value']))
        outliers = df[z_scores > 3]
        
        # Format results based on analysis type
        if analysis_type == "general":
            result = {
                "summary": {
                    "trend_direction": trend_direction,
                    "trend_strength": trend_strength,
                    "trend_significance": trend_significance,
                    "has_seasonality": has_seasonality,
                    "seasonality_period": seasonality_period,
                    "volatility": volatility,
                    "outlier_count": len(outliers)
                },
                "statistics": {
                    "mean": mean_value,
                    "median": median_value,
                    "std_dev": std_dev,
                    "min": min_value,
                    "max": max_value,
                    "range": max_value - min_value
                },
                "trend_details": {
                    "slope": slope,
                    "intercept": intercept,
                    "r_squared": r_value**2,
                    "p_value": p_value,
                    "std_err": std_err
                }
            }
        elif analysis_type == "trend_only":
            result = {
                "trend_direction": trend_direction,
                "trend_strength": trend_strength,
                "trend_significance": trend_significance,
                "slope": slope,
                "r_squared": r_value**2,
                "p_value": p_value
            }
        elif analysis_type == "seasonality":
            result = {
                "has_seasonality": has_seasonality,
                "seasonality_period": seasonality_period,
                "seasonality_strength": weekly_corr if has_seasonality else None
            }
        elif analysis_type == "volatility":
            result = {
                "volatility": volatility,
                "std_dev": std_dev,
                "mean": mean_value,
                "coefficient_of_variation": volatility
            }
        elif analysis_type == "outliers":
            result = {
                "outlier_count": len(outliers),
                "outliers": [
                    {"date": row['date'].strftime("%Y-%m-%d"), "value": row['value'], "z_score": z_scores[i]}
                    for i, row in outliers.iterrows()
                ]
            }
        else:
            result = {
                "error": f"Unsupported analysis type: {analysis_type}"
            }
        
        return result
        
    except Exception as e:
        logger.error(f"Error performing trend analysis: {str(e)}")
        frappe.log_error(f"Error performing trend analysis: {str(e)}", "Trend Analysis Error")
        return {"error": str(e)}

def store_trend_analysis(metric_id, analysis_result, task_data):
    """Store trend analysis result"""
    try:
        # Create a new AIInsight document
        insight = frappe.new_doc("AIInsight")
        insight.title = f"Trend Analysis - {task_data.get('metric_name', metric_id)}"
        insight.insight_type = "Trend Analysis"
        insight.metrics = metric_id
        insight.insight_details = json.dumps(analysis_result)
        insight.generation_date = datetime.now()
        insight.generated_by = "AetherCore Agent"
        insight.task_reference = task_data.get("task_id")
        
        # Set confidence based on analysis result
        if "summary" in analysis_result and "trend_significance" in analysis_result["summary"]:
            insight.confidence = 0.9 if analysis_result["summary"]["trend_significance"] else 0.6
        else:
            insight.confidence = 0.7
        
        insight.insert()
        
        return insight.name
        
    except Exception as e:
        logger.error(f"Error storing trend analysis: {str(e)}")
        frappe.log_error(f"Error storing trend analysis: {str(e)}", "Analysis Storage Error")
        return None

def generate_trend_recommendations(metric_doc, insight_data):
    """Generate recommendations based on trend insights"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        trend_direction = insight_data.get("trend_direction", "increasing")
        trend_strength = insight_data.get("trend_strength", 0.5)
        trend_significance = insight_data.get("trend_significance", False)
        
        if not trend_significance or trend_strength < 0.3:
            return [{
                "title": "Monitor trend for further developments",
                "description": f"The current trend in {metric_doc.metric_name} is not statistically significant. Continue monitoring for more definitive patterns.",
                "priority": "Low",
                "actions": [
                    "Continue regular monitoring",
                    "Review again in 30 days",
                    "Consider additional data sources for context"
                ]
            }]
        
        if trend_direction == "increasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Capitalize on positive trend in {metric_doc.metric_name}",
                "description": f"There is a statistically significant increasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "High" if trend_strength > 0.7 else "Medium",
                "actions": [
                    "Increase inventory levels to meet projected demand",
                    "Review staffing levels to ensure adequate coverage",
                    "Analyze which products or services are driving the growth",
                    "Consider promotional activities to capitalize on positive trend"
                ]
            }]
        elif trend_direction == "decreasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Address declining trend in {metric_doc.metric_name}",
                "description": f"There is a statistically significant decreasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "High" if trend_strength > 0.7 else "Medium",
                "actions": [
                    "Investigate root causes of the declining trend",
                    "Review pricing strategy and competitive positioning",
                    "Develop marketing campaigns to reverse the trend",
                    "Consider cost reduction measures if trend continues"
                ]
            }]
        elif trend_direction == "increasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Mitigate rising costs in {metric_doc.metric_name}",
                "description": f"There is a statistically significant increasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "High" if trend_strength > 0.7 else "Medium",
                "actions": [
                    "Identify drivers of cost increases",
                    "Review vendor contracts and consider renegotiation",
                    "Implement cost control measures",
                    "Evaluate process efficiency improvements"
                ]
            }]
        elif trend_direction == "decreasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Sustain cost improvements in {metric_doc.metric_name}",
                "description": f"There is a statistically significant decreasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "Medium",
                "actions": [
                    "Document cost-saving measures for replication",
                    "Ensure quality and service levels are maintained",
                    "Reinvest savings in growth opportunities",
                    "Share best practices across the organization"
                ]
            }]
        else:
            return [{
                "title": f"Evaluate implications of {trend_direction} trend in {metric_doc.metric_name}",
                "description": f"There is a statistically significant {trend_direction} trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "Medium",
                "actions": [
                    "Analyze business impact of the trend",
                    "Develop response strategies",
                    "Monitor related metrics for correlation",
                    "Review historical patterns for context"
                ]
            }]
        
    except Exception as e:
        logger.error(f"Error generating trend recommendations: {str(e)}")
        frappe.log_error(f"Error generating trend recommendations: {str(e)}", "Recommendation Error")
        return []

def generate_anomaly_recommendations(metric_doc, insight_data):
    """Generate recommendations based on anomaly insights"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        value = insight_data.get("value")
        expected_value = insight_data.get("expected_value")
        deviation = insight_data.get("deviation")
        severity = insight_data.get("severity", "Medium")
        
        if not value or not expected_value:
            return [{
                "title": "Investigate potential anomaly",
                "description": f"A potential anomaly has been detected in {metric_doc.metric_name}, but details are limited.",
                "priority": "Medium",
                "actions": [
                    "Verify data accuracy",
                    "Check for system issues",
                    "Review business context for the time period"
                ]
            }]
        
        percent_deviation = (value - expected_value) / expected_value * 100 if expected_value else 0
        direction = "above" if percent_deviation > 0 else "below"
        
        if direction == "above" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Investigate positive spike in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% above expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy to confirm the spike",
                    "Identify which products or services contributed to the increase",
                    "Analyze marketing or sales activities that may have driven the spike",
                    "Consider if this represents a new trend or a one-time event"
                ]
            }]
        elif direction == "below" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Address significant drop in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% below expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy to confirm the drop",
                    "Check for system issues or data collection problems",
                    "Investigate competitive actions or market changes",
                    "Develop immediate response plan if confirmed"
                ]
            }]
        elif direction == "above" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Investigate cost spike in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% above expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy to confirm the spike",
                    "Identify specific cost categories contributing to the increase",
                    "Check for duplicate transactions or accounting errors",
                    "Implement immediate cost controls if confirmed"
                ]
            }]
        elif direction == "below" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Analyze cost reduction in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% below expected value of {expected_value:.2f}.",
                "priority": "Medium",
                "actions": [
                    "Verify data accuracy to confirm the drop",
                    "Identify which cost categories decreased",
                    "Document cost-saving measures for replication",
                    "Ensure service quality has not been compromised"
                ]
            }]
        else:
            return [{
                "title": f"Investigate anomaly in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% {direction} expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy",
                    "Investigate business context during the anomaly period",
                    "Check for correlation with other metrics",
                    "Monitor for recurrence of similar patterns"
                ]
            }]
        
    except Exception as e:
        logger.error(f"Error generating anomaly recommendations: {str(e)}")
        frappe.log_error(f"Error generating anomaly recommendations: {str(e)}", "Recommendation Error")
        return []

def generate_forecast_recommendations(metric_doc, insight_data):
    """Generate recommendations based on forecast insights"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        first_value = insight_data.get("first_value")
        last_value = insight_data.get("last_value")
        forecast_horizon = insight_data.get("forecast_horizon", 30)
        
        if not first_value or not last_value:
            return [{
                "title": "Review forecast implications",
                "description": f"A forecast has been generated for {metric_doc.metric_name}, but detailed analysis is limited.",
                "priority": "Medium",
                "actions": [
                    "Review complete forecast details",
                    "Consider implications for planning",
                    "Monitor actual values against forecast"
                ]
            }]
        
        percent_change = (last_value - first_value) / first_value * 100
        trend = "increasing" if percent_change > 0 else "decreasing"
        
        if abs(percent_change) < 5:
            return [{
                "title": f"Maintain current strategies for {metric_doc.metric_name}",
                "description": f"Forecast shows a stable trend (±{abs(percent_change):.2f}%) over the next {forecast_horizon} periods.",
                "priority": "Low",
                "actions": [
                    "Continue current operational strategies",
                    "Monitor for deviations from forecast",
                    "Review again in half the forecast horizon"
                ]
            }]
        
        if trend == "increasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Prepare for growth in {metric_doc.metric_name}",
                "description": f"Forecast shows an increasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "High" if abs(percent_change) > 20 else "Medium",
                "actions": [
                    "Increase inventory levels to meet projected demand",
                    "Review staffing levels to ensure adequate coverage",
                    "Analyze which products or services are driving the growth",
                    "Consider promotional activities to capitalize on positive trend"
                ]
            }]
        elif trend == "decreasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Prepare for decline in {metric_doc.metric_name}",
                "description": f"Forecast shows a decreasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "High" if abs(percent_change) > 20 else "Medium",
                "actions": [
                    "Develop strategies to reverse the projected decline",
                    "Review pricing and promotional strategies",
                    "Consider cost reduction measures if decline materializes",
                    "Increase marketing efforts in key segments"
                ]
            }]
        elif trend == "increasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Prepare for cost increases in {metric_doc.metric_name}",
                "description": f"Forecast shows an increasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "High" if abs(percent_change) > 20 else "Medium",
                "actions": [
                    "Identify drivers of projected cost increases",
                    "Develop cost containment strategies",
                    "Review vendor contracts and consider renegotiation",
                    "Implement efficiency improvements"
                ]
            }]
        elif trend == "decreasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Leverage projected cost reductions in {metric_doc.metric_name}",
                "description": f"Forecast shows a decreasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "Medium",
                "actions": [
                    "Validate drivers of projected cost decreases",
                    "Plan for reinvestment of cost savings",
                    "Ensure quality is maintained despite cost reductions",
                    "Document successful cost reduction strategies"
                ]
            }]
        else:
            return [{
                "title": f"Prepare for {trend} trend in {metric_doc.metric_name}",
                "description": f"Forecast shows a {trend} trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "Medium",
                "actions": [
                    "Analyze business implications of the projected trend",
                    "Develop appropriate response strategies",
                    "Monitor actual values against forecast",
                    "Review related metrics for correlation"
                ]
            }]
        
    except Exception as e:
        logger.error(f"Error generating forecast recommendations: {str(e)}")
        frappe.log_error(f"Error generating forecast recommendations: {str(e)}", "Recommendation Error")
        return []

def generate_general_recommendations(metric_doc, insight_data):
    """Generate general recommendations"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        return [{
            "title": f"Review performance of {metric_doc.metric_name}",
            "description": f"Regular review of {metric_doc.metric_name} is recommended to identify opportunities and risks.",
            "priority": "Medium",
            "actions": [
                "Analyze historical trends and patterns",
                "Compare against industry benchmarks",
                "Identify key drivers and influencing factors",
                "Develop strategies to optimize performance"
            ]
        }]
        
    except Exception as e:
        logger.error(f"Error generating general recommendations: {str(e)}")
        frappe.log_error(f"Error generating general recommendations: {str(e)}", "Recommendation Error")
        return []

def create_recommendation(metric_doc, insight_type, recommendations, task_data):
    """Create a recommendation document"""
    try:
        if not recommendations:
            return None
            
        # Use the first recommendation
        recommendation = recommendations[0]
        
        # Create new recommendation
        new_recommendation = frappe.new_doc("Recommendation")
        new_recommendation.title = recommendation["title"]
        new_recommendation.description = recommendation["description"]
        new_recommendation.recommendation_type = "Opportunity" if "opportunity" in recommendation["title"].lower() else "Risk"
        new_recommendation.priority = recommendation["priority"]
        new_recommendation.source = f"AetherCore Agent - {insight_type.capitalize()}"
        new_recommendation.source_reference = task_data.get("task_id")
        new_recommendation.metric = metric_doc.name
        
        # Set impact (placeholder)
        impact = {
            "financial_impact": {
                "estimated_value": None,
                "confidence": 0.7
            },
            "operational_impact": "Medium",
            "customer_impact": "Low",
            "timeframe": "Medium-term",
            "affected_areas": ["Operations"]
        }
        new_recommendation.impact = json.dumps(impact)
        
        # Set suggested actions
        new_recommendation.suggested_actions = json.dumps(recommendation["actions"])
        
        # Set confidence
        new_recommendation.confidence = 0.8
        
        # Set status and dates
        new_recommendation.status = "New"
        new_recommendation.creation_date = datetime.now()
        
        new_recommendation.insert()
        
        return new_recommendation.name
        
    except Exception as e:
        logger.error(f"Error creating recommendation: {str(e)}")
        frappe.log_error(f"Error creating recommendation: {str(e)}", "Recommendation Creation Error")
        return None

def generate_insight_explanation(insight_doc, format_type, audience):
    """Generate explanation for an insight"""
    try:
        # This would be implemented with actual explanation generation logic
        # For now, return placeholder explanation
        
        insight_details = None
        if insight_doc.insight_details:
            try:
                insight_details = json.loads(insight_doc.insight_details)
            except json.JSONDecodeError:
                insight_details = None
        
        if format_type == "text":
            if audience == "technical":
                explanation = f"""
# Technical Analysis: {insight_doc.title}

## Overview
This insight was generated on {insight_doc.generation_date} with a confidence level of {insight_doc.confidence:.2f}.

## Details
The analysis was performed on the following metrics: {insight_doc.metrics}.

{generate_technical_details(insight_doc, insight_details)}

## Methodology
The analysis used statistical methods to identify patterns and anomalies in the data.

## Confidence Assessment
The confidence score of {insight_doc.confidence:.2f} indicates {get_confidence_description(insight_doc.confidence)}.
"""
            else:  # business audience
                explanation = f"""
# Business Summary: {insight_doc.title}

## Key Takeaway
{generate_business_summary(insight_doc, insight_details)}

## Business Impact
{generate_business_impact(insight_doc, insight_details)}

## Recommended Actions
{generate_recommended_actions(insight_doc, insight_details)}

## Next Steps
We recommend reviewing this insight with the relevant stakeholders and developing an action plan.
"""
        elif format_type == "html":
            if audience == "technical":
                explanation = f"""
<h1>Technical Analysis: {insight_doc.title}</h1>

<h2>Overview</h2>
<p>This insight was generated on {insight_doc.generation_date} with a confidence level of {insight_doc.confidence:.2f}.</p>

<h2>Details</h2>
<p>The analysis was performed on the following metrics: {insight_doc.metrics}.</p>

{generate_technical_details_html(insight_doc, insight_details)}

<h2>Methodology</h2>
<p>The analysis used statistical methods to identify patterns and anomalies in the data.</p>

<h2>Confidence Assessment</h2>
<p>The confidence score of {insight_doc.confidence:.2f} indicates {get_confidence_description(insight_doc.confidence)}.</p>
"""
            else:  # business audience
                explanation = f"""
<h1>Business Summary: {insight_doc.title}</h1>

<h2>Key Takeaway</h2>
<p>{generate_business_summary(insight_doc, insight_details)}</p>

<h2>Business Impact</h2>
<p>{generate_business_impact(insight_doc, insight_details)}</p>

<h2>Recommended Actions</h2>
<ul>
{generate_recommended_actions_html(insight_doc, insight_details)}
</ul>

<h2>Next Steps</h2>
<p>We recommend reviewing this insight with the relevant stakeholders and developing an action plan.</p>
"""
        else:
            explanation = f"Explanation for {insight_doc.title} (Format: {format_type}, Audience: {audience})"
        
        return explanation
        
    except Exception as e:
        logger.error(f"Error generating insight explanation: {str(e)}")
        frappe.log_error(f"Error generating insight explanation: {str(e)}", "Explanation Error")
        return f"Error generating explanation: {str(e)}"

def generate_technical_details(insight_doc, insight_details):
    """Generate technical details for an insight explanation"""
    if not insight_details:
        return "Detailed analysis data is not available."
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            return f"""
The trend analysis shows a {summary.get('trend_direction', 'unknown')} trend with a strength of {summary.get('trend_strength', 'N/A')}.
The trend is {'statistically significant' if summary.get('trend_significance') else 'not statistically significant'}.
{'Seasonality was detected with a period of ' + str(summary.get('seasonality_period')) + ' days.' if summary.get('has_seasonality') else 'No significant seasonality was detected.'}
The data shows a volatility of {summary.get('volatility', 'N/A')}.
{summary.get('outlier_count', 0)} outliers were detected in the data.
"""
        else:
            return "Trend analysis details are not available in a structured format."
    else:
        return "Technical details for this insight type are not available."

def generate_technical_details_html(insight_doc, insight_details):
    """Generate technical details in HTML format for an insight explanation"""
    if not insight_details:
        return "<p>Detailed analysis data is not available.</p>"
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            return f"""
<p>The trend analysis shows a <strong>{summary.get('trend_direction', 'unknown')}</strong> trend with a strength of <strong>{summary.get('trend_strength', 'N/A')}</strong>.</p>
<p>The trend is <strong>{'statistically significant' if summary.get('trend_significance') else 'not statistically significant'}</strong>.</p>
<p>{'<strong>Seasonality</strong> was detected with a period of ' + str(summary.get('seasonality_period')) + ' days.' if summary.get('has_seasonality') else 'No significant seasonality was detected.'}</p>
<p>The data shows a volatility of <strong>{summary.get('volatility', 'N/A')}</strong>.</p>
<p><strong>{summary.get('outlier_count', 0)}</strong> outliers were detected in the data.</p>
"""
        else:
            return "<p>Trend analysis details are not available in a structured format.</p>"
    else:
        return "<p>Technical details for this insight type are not available.</p>"

def generate_business_summary(insight_doc, insight_details):
    """Generate business summary for an insight explanation"""
    if not insight_details:
        return "This insight highlights important patterns in your business data that may require attention."
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            trend_strength = summary.get('trend_strength', 0)
            trend_significance = summary.get('trend_significance', False)
            
            if trend_significance and trend_strength > 0.5:
                return f"The data shows a strong and significant {trend_direction} trend that warrants attention and potential action."
            elif trend_significance:
                return f"The data shows a statistically significant {trend_direction} trend, though the effect is moderate."
            else:
                return "The data does not show a statistically significant trend at this time."
        else:
            return "This trend analysis highlights important patterns in your business data."
    else:
        return "This insight highlights important patterns in your business data that may require attention."

def generate_business_impact(insight_doc, insight_details):
    """Generate business impact for an insight explanation"""
    if not insight_details:
        return "The business impact of this insight depends on the specific metrics involved and your business context."
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            
            if trend_direction == "increasing":
                return "The increasing trend may indicate growth opportunities or potential cost increases, depending on the metric involved. This could affect resource planning, budgeting, and strategic decision-making."
            elif trend_direction == "decreasing":
                return "The decreasing trend may indicate potential revenue challenges or cost efficiencies, depending on the metric involved. This could impact financial forecasts, operational planning, and strategic initiatives."
            else:
                return "The identified trend may have significant implications for your business operations, financial performance, and strategic planning."
        else:
            return "This trend analysis may have significant implications for your business that should be evaluated in context."
    else:
        return "The business impact of this insight depends on the specific metrics involved and your business context."

def generate_recommended_actions(insight_doc, insight_details):
    """Generate recommended actions for an insight explanation"""
    if not insight_details:
        return "1. Review the insight details\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Monitor for further developments"
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            trend_significance = summary.get('trend_significance', False)
            
            if not trend_significance:
                return "1. Continue monitoring the metric for more definitive trends\n2. Review related metrics for additional context\n3. Establish alerts for significant changes"
            
            if trend_direction == "increasing":
                return "1. Analyze the drivers behind the increasing trend\n2. Evaluate resource requirements to support or manage the trend\n3. Develop strategies to capitalize on opportunities or mitigate risks\n4. Establish regular monitoring and reporting"
            elif trend_direction == "decreasing":
                return "1. Investigate the causes of the decreasing trend\n2. Assess the business impact if the trend continues\n3. Develop response strategies appropriate to the metric\n4. Implement regular tracking and review processes"
            else:
                return "1. Analyze the trend in detail\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Implement regular monitoring"
        else:
            return "1. Review the trend analysis in detail\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Monitor for further developments"
    else:
        return "1. Review the insight details\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Monitor for further developments"

def generate_recommended_actions_html(insight_doc, insight_details):
    """Generate recommended actions in HTML format for an insight explanation"""
    if not insight_details:
        return "<li>Review the insight details</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Monitor for further developments</li>"
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            trend_significance = summary.get('trend_significance', False)
            
            if not trend_significance:
                return "<li>Continue monitoring the metric for more definitive trends</li><li>Review related metrics for additional context</li><li>Establish alerts for significant changes</li>"
            
            if trend_direction == "increasing":
                return "<li>Analyze the drivers behind the increasing trend</li><li>Evaluate resource requirements to support or manage the trend</li><li>Develop strategies to capitalize on opportunities or mitigate risks</li><li>Establish regular monitoring and reporting</li>"
            elif trend_direction == "decreasing":
                return "<li>Investigate the causes of the decreasing trend</li><li>Assess the business impact if the trend continues</li><li>Develop response strategies appropriate to the metric</li><li>Implement regular tracking and review processes</li>"
            else:
                return "<li>Analyze the trend in detail</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Implement regular monitoring</li>"
        else:
            return "<li>Review the trend analysis in detail</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Monitor for further developments</li>"
    else:
        return "<li>Review the insight details</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Monitor for further developments</li>"

def get_confidence_description(confidence):
    """Get description for confidence level"""
    if confidence >= 0.9:
        return "high confidence in the analysis results"
    elif confidence >= 0.7:
        return "good confidence in the analysis results"
    elif confidence >= 0.5:
        return "moderate confidence in the analysis results"
    else:
        return "low confidence in the analysis results""""
AetherCore integration module for Synapse
"""

import frappe
import json
from datetime import datetime, timedelta
import logging

# Configure logger
logger = logging.getLogger(__name__)

# Agent task handlers

def analyze_trend(task_data):
    """Handle synapse.analyze_trend agent task"""
    try:
        logger.info(f"Handling synapse.analyze_trend agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        start_date = task_data.get("start_date")
        end_date = task_data.get("end_date")
        analysis_type = task_data.get("analysis_type", "general")
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Get historical data
        historical_data = get_metric_historical_data(metric_id, start_date, end_date)
        
        # Perform trend analysis
        analysis_result = perform_trend_analysis(metric_doc, historical_data, analysis_type)
        
        # Store analysis result if requested
        if task_data.get("store_result", False):
            store_trend_analysis(metric_id, analysis_result, task_data)
        
        return {
            "success": True,
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "analysis_type": analysis_type,
            "analysis_result": analysis_result
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.analyze_trend task: {str(e)}")
        frappe.log_error(f"Error handling synapse.analyze_trend task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def generate_forecast(task_data):
    """Handle synapse.generate_forecast agent task"""
    try:
        logger.info(f"Handling synapse.generate_forecast agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        forecast_horizon = task_data.get("forecast_horizon", 30)
        forecast_frequency = task_data.get("forecast_frequency", "Daily")
        forecast_model = task_data.get("forecast_model", "ARIMA")
        model_parameters = task_data.get("model_parameters", {})
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Create a new forecast
        forecast_doc = frappe.new_doc("Forecast")
        forecast_doc.forecast_name = f"Agent Generated Forecast - {metric_doc.metric_name}"
        forecast_doc.metric = metric_id
        forecast_doc.description = f"Forecast generated by AetherCore agent task {task_data.get('task_id')}"
        forecast_doc.status = "Draft"
        forecast_doc.forecast_model = forecast_model
        forecast_doc.forecast_horizon = forecast_horizon
        forecast_doc.forecast_frequency = forecast_frequency
        forecast_doc.model_parameters = json.dumps(model_parameters) if isinstance(model_parameters, dict) else None
        forecast_doc.confidence_level = task_data.get("confidence_level", 95)
        forecast_doc.include_prediction_intervals = 1
        forecast_doc.created_by = "AetherCore Agent"
        forecast_doc.creation_date = datetime.now()
        forecast_doc.is_active = 1
        forecast_doc.insert()
        
        # Generate the forecast
        from cauldron_synapse.predictive_analytics.forecasting import generate_forecast as run_forecast
        forecast_result = run_forecast(forecast_doc.name)
        
        return {
            "success": forecast_result.get("success", False),
            "forecast_id": forecast_doc.name,
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "forecast_data": forecast_result.get("forecast"),
            "performance": forecast_result.get("performance")
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.generate_forecast task: {str(e)}")
        frappe.log_error(f"Error handling synapse.generate_forecast task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def detect_anomalies(task_data):
    """Handle synapse.detect_anomalies agent task"""
    try:
        logger.info(f"Handling synapse.detect_anomalies agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        lookback_days = task_data.get("lookback_days", 90)
        detection_methods = task_data.get("detection_methods", ["statistical", "ml", "time_series"])
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Run anomaly detection
        from cauldron_synapse.predictive_analytics.anomaly_detection import detect_anomalies_for_metric
        detection_result = detect_anomalies_for_metric(metric_id)
        
        return {
            "success": detection_result.get("success", False),
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "anomalies_found": detection_result.get("anomalies_found", 0),
            "anomalies": detection_result.get("anomalies", [])
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.detect_anomalies task: {str(e)}")
        frappe.log_error(f"Error handling synapse.detect_anomalies task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def recommend_actions(task_data):
    """Handle synapse.recommend_actions agent task"""
    try:
        logger.info(f"Handling synapse.recommend_actions agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        metric_id = task_data.get("metric_id")
        insight_type = task_data.get("insight_type", "trend")
        insight_data = task_data.get("insight_data", {})
        
        if not metric_id:
            return {
                "success": False,
                "error": "Missing required parameter: metric_id"
            }
        
        # Get metric details
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Generate recommendations based on insight type
        if insight_type == "trend":
            recommendations = generate_trend_recommendations(metric_doc, insight_data)
        elif insight_type == "anomaly":
            recommendations = generate_anomaly_recommendations(metric_doc, insight_data)
        elif insight_type == "forecast":
            recommendations = generate_forecast_recommendations(metric_doc, insight_data)
        else:
            recommendations = generate_general_recommendations(metric_doc, insight_data)
        
        # Create recommendation if requested
        recommendation_id = None
        if task_data.get("create_recommendation", False) and recommendations:
            recommendation_id = create_recommendation(metric_doc, insight_type, recommendations, task_data)
        
        return {
            "success": True,
            "metric_id": metric_id,
            "metric_name": metric_doc.metric_name,
            "insight_type": insight_type,
            "recommendations": recommendations,
            "recommendation_id": recommendation_id
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.recommend_actions task: {str(e)}")
        frappe.log_error(f"Error handling synapse.recommend_actions task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

def explain_insight(task_data):
    """Handle synapse.explain_insight agent task"""
    try:
        logger.info(f"Handling synapse.explain_insight agent task: {task_data.get('task_id')}")
        
        # Extract task parameters
        insight_id = task_data.get("insight_id")
        format_type = task_data.get("format", "text")
        audience = task_data.get("audience", "technical")
        
        if not insight_id:
            return {
                "success": False,
                "error": "Missing required parameter: insight_id"
            }
        
        # Get insight details
        insight_doc = frappe.get_doc("AIInsight", insight_id)
        
        # Generate explanation based on format and audience
        explanation = generate_insight_explanation(insight_doc, format_type, audience)
        
        # Update insight with explanation if requested
        if task_data.get("update_insight", False):
            insight_doc.explanation = explanation
            insight_doc.save()
        
        return {
            "success": True,
            "insight_id": insight_id,
            "insight_title": insight_doc.title,
            "format": format_type,
            "audience": audience,
            "explanation": explanation
        }
        
    except Exception as e:
        logger.error(f"Error handling synapse.explain_insight task: {str(e)}")
        frappe.log_error(f"Error handling synapse.explain_insight task: {str(e)}", "AetherCore Task Error")
        return {
            "success": False,
            "error": str(e)
        }

# Helper functions

def get_metric_historical_data(metric_id, start_date=None, end_date=None):
    """Get historical data for a metric"""
    try:
        metric_doc = frappe.get_doc("AnalyticsMetric", metric_id)
        
        # Set default date range if not provided
        if not end_date:
            end_date = datetime.now().date()
        elif isinstance(end_date, str):
            end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
            
        if not start_date:
            start_date = end_date - timedelta(days=90)
        elif isinstance(start_date, str):
            start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
        
        # Get historical values
        # This would be implemented to fetch actual historical data
        # For now, return placeholder data
        
        # Generate some realistic sample data
        days = (end_date - start_date).days + 1
        dates = [start_date + timedelta(days=i) for i in range(days)]
        
        import numpy as np
        
        # Create a trend with seasonality and some noise
        trend = np.linspace(100, 150, days)  # Upward trend from 100 to 150
        seasonality = 20 * np.sin(np.linspace(0, 6*np.pi, days))  # Seasonal component
        noise = np.random.normal(0, 5, days)  # Random noise
        
        values = trend + seasonality + noise
        
        # Create data points
        data = [
            {"date": date.strftime("%Y-%m-%d"), "value": value}
            for date, value in zip(dates, values)
        ]
        
        return data
        
    except Exception as e:
        logger.error(f"Error getting historical data for metric {metric_id}: {str(e)}")
        frappe.log_error(f"Error getting historical data for metric {metric_id}: {str(e)}", "Historical Data Error")
        return []

def perform_trend_analysis(metric_doc, historical_data, analysis_type):
    """Perform trend analysis on historical data"""
    try:
        # This would be implemented with actual trend analysis logic
        # For now, return placeholder analysis
        
        import pandas as pd
        import numpy as np
        from scipy import stats
        
        # Convert to DataFrame
        df = pd.DataFrame(historical_data)
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        # Basic statistics
        mean_value = df['value'].mean()
        median_value = df['value'].median()
        std_dev = df['value'].std()
        min_value = df['value'].min()
        max_value = df['value'].max()
        
        # Trend analysis
        x = np.arange(len(df))
        y = df['value'].values
        slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
        
        trend_direction = "increasing" if slope > 0 else "decreasing"
        trend_strength = abs(r_value)
        trend_significance = p_value < 0.05
        
        # Seasonality detection (simplified)
        has_seasonality = False
        seasonality_period = None
        
        if len(df) >= 14:  # Need at least 2 weeks of data
            # Check for weekly seasonality
            weekly_corr = df['value'].autocorr(lag=7)
            if abs(weekly_corr) > 0.3:
                has_seasonality = True
                seasonality_period = 7
        
        # Volatility
        volatility = std_dev / mean_value
        
        # Outliers
        z_scores = np.abs(stats.zscore(df['value']))
        outliers = df[z_scores > 3]
        
        # Format results based on analysis type
        if analysis_type == "general":
            result = {
                "summary": {
                    "trend_direction": trend_direction,
                    "trend_strength": trend_strength,
                    "trend_significance": trend_significance,
                    "has_seasonality": has_seasonality,
                    "seasonality_period": seasonality_period,
                    "volatility": volatility,
                    "outlier_count": len(outliers)
                },
                "statistics": {
                    "mean": mean_value,
                    "median": median_value,
                    "std_dev": std_dev,
                    "min": min_value,
                    "max": max_value,
                    "range": max_value - min_value
                },
                "trend_details": {
                    "slope": slope,
                    "intercept": intercept,
                    "r_squared": r_value**2,
                    "p_value": p_value,
                    "std_err": std_err
                }
            }
        elif analysis_type == "trend_only":
            result = {
                "trend_direction": trend_direction,
                "trend_strength": trend_strength,
                "trend_significance": trend_significance,
                "slope": slope,
                "r_squared": r_value**2,
                "p_value": p_value
            }
        elif analysis_type == "seasonality":
            result = {
                "has_seasonality": has_seasonality,
                "seasonality_period": seasonality_period,
                "seasonality_strength": weekly_corr if has_seasonality else None
            }
        elif analysis_type == "volatility":
            result = {
                "volatility": volatility,
                "std_dev": std_dev,
                "mean": mean_value,
                "coefficient_of_variation": volatility
            }
        elif analysis_type == "outliers":
            result = {
                "outlier_count": len(outliers),
                "outliers": [
                    {"date": row['date'].strftime("%Y-%m-%d"), "value": row['value'], "z_score": z_scores[i]}
                    for i, row in outliers.iterrows()
                ]
            }
        else:
            result = {
                "error": f"Unsupported analysis type: {analysis_type}"
            }
        
        return result
        
    except Exception as e:
        logger.error(f"Error performing trend analysis: {str(e)}")
        frappe.log_error(f"Error performing trend analysis: {str(e)}", "Trend Analysis Error")
        return {"error": str(e)}

def store_trend_analysis(metric_id, analysis_result, task_data):
    """Store trend analysis result"""
    try:
        # Create a new AIInsight document
        insight = frappe.new_doc("AIInsight")
        insight.title = f"Trend Analysis - {task_data.get('metric_name', metric_id)}"
        insight.insight_type = "Trend Analysis"
        insight.metrics = metric_id
        insight.insight_details = json.dumps(analysis_result)
        insight.generation_date = datetime.now()
        insight.generated_by = "AetherCore Agent"
        insight.task_reference = task_data.get("task_id")
        
        # Set confidence based on analysis result
        if "summary" in analysis_result and "trend_significance" in analysis_result["summary"]:
            insight.confidence = 0.9 if analysis_result["summary"]["trend_significance"] else 0.6
        else:
            insight.confidence = 0.7
        
        insight.insert()
        
        return insight.name
        
    except Exception as e:
        logger.error(f"Error storing trend analysis: {str(e)}")
        frappe.log_error(f"Error storing trend analysis: {str(e)}", "Analysis Storage Error")
        return None

def generate_trend_recommendations(metric_doc, insight_data):
    """Generate recommendations based on trend insights"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        trend_direction = insight_data.get("trend_direction", "increasing")
        trend_strength = insight_data.get("trend_strength", 0.5)
        trend_significance = insight_data.get("trend_significance", False)
        
        if not trend_significance or trend_strength < 0.3:
            return [{
                "title": "Monitor trend for further developments",
                "description": f"The current trend in {metric_doc.metric_name} is not statistically significant. Continue monitoring for more definitive patterns.",
                "priority": "Low",
                "actions": [
                    "Continue regular monitoring",
                    "Review again in 30 days",
                    "Consider additional data sources for context"
                ]
            }]
        
        if trend_direction == "increasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Capitalize on positive trend in {metric_doc.metric_name}",
                "description": f"There is a statistically significant increasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "High" if trend_strength > 0.7 else "Medium",
                "actions": [
                    "Increase inventory levels to meet projected demand",
                    "Review staffing levels to ensure adequate coverage",
                    "Analyze which products or services are driving the growth",
                    "Consider promotional activities to capitalize on positive trend"
                ]
            }]
        elif trend_direction == "decreasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Address declining trend in {metric_doc.metric_name}",
                "description": f"There is a statistically significant decreasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "High" if trend_strength > 0.7 else "Medium",
                "actions": [
                    "Investigate root causes of the declining trend",
                    "Review pricing strategy and competitive positioning",
                    "Develop marketing campaigns to reverse the trend",
                    "Consider cost reduction measures if trend continues"
                ]
            }]
        elif trend_direction == "increasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Mitigate rising costs in {metric_doc.metric_name}",
                "description": f"There is a statistically significant increasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "High" if trend_strength > 0.7 else "Medium",
                "actions": [
                    "Identify drivers of cost increases",
                    "Review vendor contracts and consider renegotiation",
                    "Implement cost control measures",
                    "Evaluate process efficiency improvements"
                ]
            }]
        elif trend_direction == "decreasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Sustain cost improvements in {metric_doc.metric_name}",
                "description": f"There is a statistically significant decreasing trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "Medium",
                "actions": [
                    "Document cost-saving measures for replication",
                    "Ensure quality and service levels are maintained",
                    "Reinvest savings in growth opportunities",
                    "Share best practices across the organization"
                ]
            }]
        else:
            return [{
                "title": f"Evaluate implications of {trend_direction} trend in {metric_doc.metric_name}",
                "description": f"There is a statistically significant {trend_direction} trend in {metric_doc.metric_name} with strength of {trend_strength:.2f}.",
                "priority": "Medium",
                "actions": [
                    "Analyze business impact of the trend",
                    "Develop response strategies",
                    "Monitor related metrics for correlation",
                    "Review historical patterns for context"
                ]
            }]
        
    except Exception as e:
        logger.error(f"Error generating trend recommendations: {str(e)}")
        frappe.log_error(f"Error generating trend recommendations: {str(e)}", "Recommendation Error")
        return []

def generate_anomaly_recommendations(metric_doc, insight_data):
    """Generate recommendations based on anomaly insights"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        value = insight_data.get("value")
        expected_value = insight_data.get("expected_value")
        deviation = insight_data.get("deviation")
        severity = insight_data.get("severity", "Medium")
        
        if not value or not expected_value:
            return [{
                "title": "Investigate potential anomaly",
                "description": f"A potential anomaly has been detected in {metric_doc.metric_name}, but details are limited.",
                "priority": "Medium",
                "actions": [
                    "Verify data accuracy",
                    "Check for system issues",
                    "Review business context for the time period"
                ]
            }]
        
        percent_deviation = (value - expected_value) / expected_value * 100 if expected_value else 0
        direction = "above" if percent_deviation > 0 else "below"
        
        if direction == "above" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Investigate positive spike in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% above expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy to confirm the spike",
                    "Identify which products or services contributed to the increase",
                    "Analyze marketing or sales activities that may have driven the spike",
                    "Consider if this represents a new trend or a one-time event"
                ]
            }]
        elif direction == "below" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Address significant drop in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% below expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy to confirm the drop",
                    "Check for system issues or data collection problems",
                    "Investigate competitive actions or market changes",
                    "Develop immediate response plan if confirmed"
                ]
            }]
        elif direction == "above" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Investigate cost spike in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% above expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy to confirm the spike",
                    "Identify specific cost categories contributing to the increase",
                    "Check for duplicate transactions or accounting errors",
                    "Implement immediate cost controls if confirmed"
                ]
            }]
        elif direction == "below" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Analyze cost reduction in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% below expected value of {expected_value:.2f}.",
                "priority": "Medium",
                "actions": [
                    "Verify data accuracy to confirm the drop",
                    "Identify which cost categories decreased",
                    "Document cost-saving measures for replication",
                    "Ensure service quality has not been compromised"
                ]
            }]
        else:
            return [{
                "title": f"Investigate anomaly in {metric_doc.metric_name}",
                "description": f"Value of {value:.2f} is {abs(percent_deviation):.2f}% {direction} expected value of {expected_value:.2f}.",
                "priority": severity,
                "actions": [
                    "Verify data accuracy",
                    "Investigate business context during the anomaly period",
                    "Check for correlation with other metrics",
                    "Monitor for recurrence of similar patterns"
                ]
            }]
        
    except Exception as e:
        logger.error(f"Error generating anomaly recommendations: {str(e)}")
        frappe.log_error(f"Error generating anomaly recommendations: {str(e)}", "Recommendation Error")
        return []

def generate_forecast_recommendations(metric_doc, insight_data):
    """Generate recommendations based on forecast insights"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        first_value = insight_data.get("first_value")
        last_value = insight_data.get("last_value")
        forecast_horizon = insight_data.get("forecast_horizon", 30)
        
        if not first_value or not last_value:
            return [{
                "title": "Review forecast implications",
                "description": f"A forecast has been generated for {metric_doc.metric_name}, but detailed analysis is limited.",
                "priority": "Medium",
                "actions": [
                    "Review complete forecast details",
                    "Consider implications for planning",
                    "Monitor actual values against forecast"
                ]
            }]
        
        percent_change = (last_value - first_value) / first_value * 100
        trend = "increasing" if percent_change > 0 else "decreasing"
        
        if abs(percent_change) < 5:
            return [{
                "title": f"Maintain current strategies for {metric_doc.metric_name}",
                "description": f"Forecast shows a stable trend (±{abs(percent_change):.2f}%) over the next {forecast_horizon} periods.",
                "priority": "Low",
                "actions": [
                    "Continue current operational strategies",
                    "Monitor for deviations from forecast",
                    "Review again in half the forecast horizon"
                ]
            }]
        
        if trend == "increasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Prepare for growth in {metric_doc.metric_name}",
                "description": f"Forecast shows an increasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "High" if abs(percent_change) > 20 else "Medium",
                "actions": [
                    "Increase inventory levels to meet projected demand",
                    "Review staffing levels to ensure adequate coverage",
                    "Analyze which products or services are driving the growth",
                    "Consider promotional activities to capitalize on positive trend"
                ]
            }]
        elif trend == "decreasing" and metric_doc.metric_type in ["Sales Metric", "Revenue Metric", "Customer Metric"]:
            return [{
                "title": f"Prepare for decline in {metric_doc.metric_name}",
                "description": f"Forecast shows a decreasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "High" if abs(percent_change) > 20 else "Medium",
                "actions": [
                    "Develop strategies to reverse the projected decline",
                    "Review pricing and promotional strategies",
                    "Consider cost reduction measures if decline materializes",
                    "Increase marketing efforts in key segments"
                ]
            }]
        elif trend == "increasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Prepare for cost increases in {metric_doc.metric_name}",
                "description": f"Forecast shows an increasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "High" if abs(percent_change) > 20 else "Medium",
                "actions": [
                    "Identify drivers of projected cost increases",
                    "Develop cost containment strategies",
                    "Review vendor contracts and consider renegotiation",
                    "Implement efficiency improvements"
                ]
            }]
        elif trend == "decreasing" and metric_doc.metric_type in ["Cost Metric", "Expense Metric"]:
            return [{
                "title": f"Leverage projected cost reductions in {metric_doc.metric_name}",
                "description": f"Forecast shows a decreasing trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "Medium",
                "actions": [
                    "Validate drivers of projected cost decreases",
                    "Plan for reinvestment of cost savings",
                    "Ensure quality is maintained despite cost reductions",
                    "Document successful cost reduction strategies"
                ]
            }]
        else:
            return [{
                "title": f"Prepare for {trend} trend in {metric_doc.metric_name}",
                "description": f"Forecast shows a {trend} trend of {abs(percent_change):.2f}% over the next {forecast_horizon} periods.",
                "priority": "Medium",
                "actions": [
                    "Analyze business implications of the projected trend",
                    "Develop appropriate response strategies",
                    "Monitor actual values against forecast",
                    "Review related metrics for correlation"
                ]
            }]
        
    except Exception as e:
        logger.error(f"Error generating forecast recommendations: {str(e)}")
        frappe.log_error(f"Error generating forecast recommendations: {str(e)}", "Recommendation Error")
        return []

def generate_general_recommendations(metric_doc, insight_data):
    """Generate general recommendations"""
    try:
        # This would be implemented with actual recommendation logic
        # For now, return placeholder recommendations
        
        return [{
            "title": f"Review performance of {metric_doc.metric_name}",
            "description": f"Regular review of {metric_doc.metric_name} is recommended to identify opportunities and risks.",
            "priority": "Medium",
            "actions": [
                "Analyze historical trends and patterns",
                "Compare against industry benchmarks",
                "Identify key drivers and influencing factors",
                "Develop strategies to optimize performance"
            ]
        }]
        
    except Exception as e:
        logger.error(f"Error generating general recommendations: {str(e)}")
        frappe.log_error(f"Error generating general recommendations: {str(e)}", "Recommendation Error")
        return []

def create_recommendation(metric_doc, insight_type, recommendations, task_data):
    """Create a recommendation document"""
    try:
        if not recommendations:
            return None
            
        # Use the first recommendation
        recommendation = recommendations[0]
        
        # Create new recommendation
        new_recommendation = frappe.new_doc("Recommendation")
        new_recommendation.title = recommendation["title"]
        new_recommendation.description = recommendation["description"]
        new_recommendation.recommendation_type = "Opportunity" if "opportunity" in recommendation["title"].lower() else "Risk"
        new_recommendation.priority = recommendation["priority"]
        new_recommendation.source = f"AetherCore Agent - {insight_type.capitalize()}"
        new_recommendation.source_reference = task_data.get("task_id")
        new_recommendation.metric = metric_doc.name
        
        # Set impact (placeholder)
        impact = {
            "financial_impact": {
                "estimated_value": None,
                "confidence": 0.7
            },
            "operational_impact": "Medium",
            "customer_impact": "Low",
            "timeframe": "Medium-term",
            "affected_areas": ["Operations"]
        }
        new_recommendation.impact = json.dumps(impact)
        
        # Set suggested actions
        new_recommendation.suggested_actions = json.dumps(recommendation["actions"])
        
        # Set confidence
        new_recommendation.confidence = 0.8
        
        # Set status and dates
        new_recommendation.status = "New"
        new_recommendation.creation_date = datetime.now()
        
        new_recommendation.insert()
        
        return new_recommendation.name
        
    except Exception as e:
        logger.error(f"Error creating recommendation: {str(e)}")
        frappe.log_error(f"Error creating recommendation: {str(e)}", "Recommendation Creation Error")
        return None

def generate_insight_explanation(insight_doc, format_type, audience):
    """Generate explanation for an insight"""
    try:
        # This would be implemented with actual explanation generation logic
        # For now, return placeholder explanation
        
        insight_details = None
        if insight_doc.insight_details:
            try:
                insight_details = json.loads(insight_doc.insight_details)
            except json.JSONDecodeError:
                insight_details = None
        
        if format_type == "text":
            if audience == "technical":
                explanation = f"""
# Technical Analysis: {insight_doc.title}

## Overview
This insight was generated on {insight_doc.generation_date} with a confidence level of {insight_doc.confidence:.2f}.

## Details
The analysis was performed on the following metrics: {insight_doc.metrics}.

{generate_technical_details(insight_doc, insight_details)}

## Methodology
The analysis used statistical methods to identify patterns and anomalies in the data.

## Confidence Assessment
The confidence score of {insight_doc.confidence:.2f} indicates {get_confidence_description(insight_doc.confidence)}.
"""
            else:  # business audience
                explanation = f"""
# Business Summary: {insight_doc.title}

## Key Takeaway
{generate_business_summary(insight_doc, insight_details)}

## Business Impact
{generate_business_impact(insight_doc, insight_details)}

## Recommended Actions
{generate_recommended_actions(insight_doc, insight_details)}

## Next Steps
We recommend reviewing this insight with the relevant stakeholders and developing an action plan.
"""
        elif format_type == "html":
            if audience == "technical":
                explanation = f"""
<h1>Technical Analysis: {insight_doc.title}</h1>

<h2>Overview</h2>
<p>This insight was generated on {insight_doc.generation_date} with a confidence level of {insight_doc.confidence:.2f}.</p>

<h2>Details</h2>
<p>The analysis was performed on the following metrics: {insight_doc.metrics}.</p>

{generate_technical_details_html(insight_doc, insight_details)}

<h2>Methodology</h2>
<p>The analysis used statistical methods to identify patterns and anomalies in the data.</p>

<h2>Confidence Assessment</h2>
<p>The confidence score of {insight_doc.confidence:.2f} indicates {get_confidence_description(insight_doc.confidence)}.</p>
"""
            else:  # business audience
                explanation = f"""
<h1>Business Summary: {insight_doc.title}</h1>

<h2>Key Takeaway</h2>
<p>{generate_business_summary(insight_doc, insight_details)}</p>

<h2>Business Impact</h2>
<p>{generate_business_impact(insight_doc, insight_details)}</p>

<h2>Recommended Actions</h2>
<ul>
{generate_recommended_actions_html(insight_doc, insight_details)}
</ul>

<h2>Next Steps</h2>
<p>We recommend reviewing this insight with the relevant stakeholders and developing an action plan.</p>
"""
        else:
            explanation = f"Explanation for {insight_doc.title} (Format: {format_type}, Audience: {audience})"
        
        return explanation
        
    except Exception as e:
        logger.error(f"Error generating insight explanation: {str(e)}")
        frappe.log_error(f"Error generating insight explanation: {str(e)}", "Explanation Error")
        return f"Error generating explanation: {str(e)}"

def generate_technical_details(insight_doc, insight_details):
    """Generate technical details for an insight explanation"""
    if not insight_details:
        return "Detailed analysis data is not available."
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            return f"""
The trend analysis shows a {summary.get('trend_direction', 'unknown')} trend with a strength of {summary.get('trend_strength', 'N/A')}.
The trend is {'statistically significant' if summary.get('trend_significance') else 'not statistically significant'}.
{'Seasonality was detected with a period of ' + str(summary.get('seasonality_period')) + ' days.' if summary.get('has_seasonality') else 'No significant seasonality was detected.'}
The data shows a volatility of {summary.get('volatility', 'N/A')}.
{summary.get('outlier_count', 0)} outliers were detected in the data.
"""
        else:
            return "Trend analysis details are not available in a structured format."
    else:
        return "Technical details for this insight type are not available."

def generate_technical_details_html(insight_doc, insight_details):
    """Generate technical details in HTML format for an insight explanation"""
    if not insight_details:
        return "<p>Detailed analysis data is not available.</p>"
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            return f"""
<p>The trend analysis shows a <strong>{summary.get('trend_direction', 'unknown')}</strong> trend with a strength of <strong>{summary.get('trend_strength', 'N/A')}</strong>.</p>
<p>The trend is <strong>{'statistically significant' if summary.get('trend_significance') else 'not statistically significant'}</strong>.</p>
<p>{'<strong>Seasonality</strong> was detected with a period of ' + str(summary.get('seasonality_period')) + ' days.' if summary.get('has_seasonality') else 'No significant seasonality was detected.'}</p>
<p>The data shows a volatility of <strong>{summary.get('volatility', 'N/A')}</strong>.</p>
<p><strong>{summary.get('outlier_count', 0)}</strong> outliers were detected in the data.</p>
"""
        else:
            return "<p>Trend analysis details are not available in a structured format.</p>"
    else:
        return "<p>Technical details for this insight type are not available.</p>"

def generate_business_summary(insight_doc, insight_details):
    """Generate business summary for an insight explanation"""
    if not insight_details:
        return "This insight highlights important patterns in your business data that may require attention."
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            trend_strength = summary.get('trend_strength', 0)
            trend_significance = summary.get('trend_significance', False)
            
            if trend_significance and trend_strength > 0.5:
                return f"The data shows a strong and significant {trend_direction} trend that warrants attention and potential action."
            elif trend_significance:
                return f"The data shows a statistically significant {trend_direction} trend, though the effect is moderate."
            else:
                return "The data does not show a statistically significant trend at this time."
        else:
            return "This trend analysis highlights important patterns in your business data."
    else:
        return "This insight highlights important patterns in your business data that may require attention."

def generate_business_impact(insight_doc, insight_details):
    """Generate business impact for an insight explanation"""
    if not insight_details:
        return "The business impact of this insight depends on the specific metrics involved and your business context."
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            
            if trend_direction == "increasing":
                return "The increasing trend may indicate growth opportunities or potential cost increases, depending on the metric involved. This could affect resource planning, budgeting, and strategic decision-making."
            elif trend_direction == "decreasing":
                return "The decreasing trend may indicate potential revenue challenges or cost efficiencies, depending on the metric involved. This could impact financial forecasts, operational planning, and strategic initiatives."
            else:
                return "The identified trend may have significant implications for your business operations, financial performance, and strategic planning."
        else:
            return "This trend analysis may have significant implications for your business that should be evaluated in context."
    else:
        return "The business impact of this insight depends on the specific metrics involved and your business context."

def generate_recommended_actions(insight_doc, insight_details):
    """Generate recommended actions for an insight explanation"""
    if not insight_details:
        return "1. Review the insight details\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Monitor for further developments"
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            trend_significance = summary.get('trend_significance', False)
            
            if not trend_significance:
                return "1. Continue monitoring the metric for more definitive trends\n2. Review related metrics for additional context\n3. Establish alerts for significant changes"
            
            if trend_direction == "increasing":
                return "1. Analyze the drivers behind the increasing trend\n2. Evaluate resource requirements to support or manage the trend\n3. Develop strategies to capitalize on opportunities or mitigate risks\n4. Establish regular monitoring and reporting"
            elif trend_direction == "decreasing":
                return "1. Investigate the causes of the decreasing trend\n2. Assess the business impact if the trend continues\n3. Develop response strategies appropriate to the metric\n4. Implement regular tracking and review processes"
            else:
                return "1. Analyze the trend in detail\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Implement regular monitoring"
        else:
            return "1. Review the trend analysis in detail\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Monitor for further developments"
    else:
        return "1. Review the insight details\n2. Evaluate business implications\n3. Develop appropriate response strategies\n4. Monitor for further developments"

def generate_recommended_actions_html(insight_doc, insight_details):
    """Generate recommended actions in HTML format for an insight explanation"""
    if not insight_details:
        return "<li>Review the insight details</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Monitor for further developments</li>"
    
    if insight_doc.insight_type == "Trend Analysis":
        if "summary" in insight_details:
            summary = insight_details["summary"]
            trend_direction = summary.get('trend_direction', 'unknown')
            trend_significance = summary.get('trend_significance', False)
            
            if not trend_significance:
                return "<li>Continue monitoring the metric for more definitive trends</li><li>Review related metrics for additional context</li><li>Establish alerts for significant changes</li>"
            
            if trend_direction == "increasing":
                return "<li>Analyze the drivers behind the increasing trend</li><li>Evaluate resource requirements to support or manage the trend</li><li>Develop strategies to capitalize on opportunities or mitigate risks</li><li>Establish regular monitoring and reporting</li>"
            elif trend_direction == "decreasing":
                return "<li>Investigate the causes of the decreasing trend</li><li>Assess the business impact if the trend continues</li><li>Develop response strategies appropriate to the metric</li><li>Implement regular tracking and review processes</li>"
            else:
                return "<li>Analyze the trend in detail</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Implement regular monitoring</li>"
        else:
            return "<li>Review the trend analysis in detail</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Monitor for further developments</li>"
    else:
        return "<li>Review the insight details</li><li>Evaluate business implications</li><li>Develop appropriate response strategies</li><li>Monitor for further developments</li>"

def get_confidence_description(confidence):
    """Get description for confidence level"""
    if confidence >= 0.9:
        return "high confidence in the analysis results"
    elif confidence >= 0.7:
        return "good confidence in the analysis results"
    elif confidence >= 0.5:
        return "moderate confidence in the analysis results"
    else:
        return "low confidence in the analysis results"